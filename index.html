<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Demo Game - Dice Roll</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        color: white;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      .container {
        max-width: 500px;
        width: 100%;
      }

      h1 {
        text-align: center;
        margin-bottom: 20px;
        color: #43e4e8;
      }

      .status-box {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 20px;
      }

      .status-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .status-label {
        color: #888;
      }

      .status-value {
        color: #43e4e8;
        word-break: break-all;
        max-width: 200px;
        text-align: right;
      }

      .status-value.connected {
        color: #4caf50;
      }

      .status-value.disconnected {
        color: #f44336;
      }

      .token-balance {
        color: #ffd700;
        font-weight: bold;
      }

      .game-area {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 15px;
        padding: 30px;
        text-align: center;
      }

      .dice {
        font-size: 80px;
        margin: 20px 0;
        animation: none;
      }

      .dice.rolling {
        animation: roll 0.3s infinite;
      }

      @keyframes roll {
        0% {
          transform: rotate(0deg);
        }
        25% {
          transform: rotate(10deg);
        }
        50% {
          transform: rotate(0deg);
        }
        75% {
          transform: rotate(-10deg);
        }
        100% {
          transform: rotate(0deg);
        }
      }

      .bet-input {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        justify-content: center;
        align-items: center;
      }

      input[type="number"] {
        width: 150px;
        padding: 12px 15px;
        border: 2px solid #ffd700;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.3);
        color: white;
        font-size: 18px;
        text-align: center;
      }

      input[type="number"]:focus {
        outline: none;
        border-color: #ffea00;
      }

      .token-symbol {
        color: #ffd700;
        font-weight: bold;
        line-height: 45px;
      }

      .btn {
        padding: 15px 40px;
        font-size: 18px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
      }

      .btn-roll {
        background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);
        color: #1a1a2e;
        font-weight: bold;
      }

      .btn-roll:hover {
        transform: scale(1.05);
        box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
      }

      .btn-roll:disabled {
        background: #555;
        color: #888;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .result {
        margin-top: 20px;
        padding: 15px;
        border-radius: 8px;
        font-size: 18px;
      }

      .result.win {
        background: rgba(76, 175, 80, 0.3);
        border: 1px solid #4caf50;
      }

      .result.lose {
        background: rgba(244, 67, 54, 0.3);
        border: 1px solid #f44336;
      }

      .log-area {
        margin-top: 20px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        padding: 15px;
        max-height: 200px;
        overflow-y: auto;
      }

      .log-title {
        color: #888;
        font-size: 12px;
        margin-bottom: 10px;
      }

      .log-item {
        font-size: 11px;
        color: #aaa;
        margin-bottom: 5px;
        font-family: monospace;
      }

      .log-item.error {
        color: #f44336;
      }

      .log-item.success {
        color: #4caf50;
      }

      .token-info {
        background: rgba(255, 215, 0, 0.1);
        border: 1px solid rgba(255, 215, 0, 0.3);
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 15px;
        font-size: 12px;
      }

      .token-info a {
        color: #ffd700;
        text-decoration: none;
      }

      .token-info a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸŽ² Demo Dice Game</h1>

      <!-- Token Info -->
      <div class="token-info">
        ðŸª™ Using Token: <a href="https://megaeth-testnet-v2.blockscout.com/token/0x10cED494da9C570cEd6005656D3fFCbc6F94f90e" target="_blank">View on Explorer</a>
      </div>

      <!-- Status Box -->
      <div class="status-box">
        <div class="status-item">
          <span class="status-label">Wallet Status:</span>
          <span id="walletStatus" class="status-value disconnected"
            >Waiting for privateKey...</span
          >
        </div>
        <div class="status-item">
          <span class="status-label">Wallet Address:</span>
          <span id="walletAddress" class="status-value">-</span>
        </div>
        <div class="status-item">
          <span class="status-label">Network:</span>
          <span class="status-value">MegaETH Testnet</span>
        </div>
        <div class="status-item">
          <span class="status-label">ETH Balance:</span>
          <span id="ethBalance" class="status-value">Loading...</span>
        </div>
        <div class="status-item">
          <span class="status-label">Token Balance:</span>
          <span id="tokenBalance" class="status-value token-balance">Loading...</span>
        </div>
      </div>

      <!-- Game Area -->
      <div class="game-area">
        <p>Roll the dice! Win if you get 4, 5, or 6</p>
        <p style="font-size: 12px; color: #888; margin-top: 5px;">Bet with ERC-20 Token & Sign Transaction</p>

        <div id="dice" class="dice">ðŸŽ²</div>

        <div class="bet-input">
          <input
            type="number"
            id="betAmount"
            value="1"
            min="0.1"
            max="1000"
            step="0.1"
            placeholder="Bet Amount"
          />
          <span class="token-symbol" id="tokenSymbolDisplay">TOKEN</span>
        </div>

        <button id="rollBtn" class="btn btn-roll" disabled>
          ðŸŽ° Roll Dice (Sign & Transfer Token)
        </button>

        <div id="result" class="result" style="display: none"></div>
      </div>

      <!-- Log Area -->
      <div class="log-area">
        <div class="log-title">ðŸ“‹ Transaction Log</div>
        <div id="logs"></div>
      </div>
    </div>

    <script>
      // ================== CONFIG ==================
      // MegaETH Testnet
      const RPC_URL = "https://carrot.megaeth.com/rpc";
      const CHAIN_ID = 6342; // 0x18c6
      const CHAIN_NAME = "MegaETH Testnet";

      // ERC-20 Token Contract
      const TOKEN_ADDRESS = "0x10cED494da9C570cEd6005656D3fFCbc6F94f90e";
      
      // Standard ERC-20 ABI (only functions we need)
      const ERC20_ABI = [
        // Read functions
        "function name() view returns (string)",
        "function symbol() view returns (string)",
        "function decimals() view returns (uint8)",
        "function balanceOf(address owner) view returns (uint256)",
        "function allowance(address owner, address spender) view returns (uint256)",
        // Write functions
        "function transfer(address to, uint256 amount) returns (bool)",
        "function approve(address spender, uint256 amount) returns (bool)",
        // Events
        "event Transfer(address indexed from, address indexed to, uint256 value)",
        "event Approval(address indexed owner, address indexed spender, uint256 value)"
      ];

      // Game treasury address (where tokens are sent when losing / received from when winning)
      // In a real game, this would be a smart contract
      const GAME_TREASURY = "0x000000000000000000000000000000000000dEaD"; // Burn address for demo

      // ================== GAME STATE ==================
      let wallet = null;
      let privateKey = null;
      let provider = null;
      let tokenContract = null;
      let ethBalance = 0;
      let tokenBalance = 0;
      let tokenDecimals = 18;
      let tokenSymbol = "TOKEN";

      // ================== DOM ELEMENTS ==================
      const walletStatus = document.getElementById("walletStatus");
      const walletAddress = document.getElementById("walletAddress");
      const ethBalanceEl = document.getElementById("ethBalance");
      const tokenBalanceEl = document.getElementById("tokenBalance");
      const tokenSymbolDisplay = document.getElementById("tokenSymbolDisplay");
      const diceEl = document.getElementById("dice");
      const betAmountEl = document.getElementById("betAmount");
      const rollBtn = document.getElementById("rollBtn");
      const resultEl = document.getElementById("result");
      const logsEl = document.getElementById("logs");

      // ================== LOGGING ==================
      function log(message, type = "info") {
        const time = new Date().toLocaleTimeString();
        const div = document.createElement("div");
        div.className = `log-item ${type}`;
        div.textContent = `[${time}] ${message}`;
        logsEl.insertBefore(div, logsEl.firstChild);
        console.log(`[Game] ${message}`);
      }

      // ================== RECEIVE PRIVATE KEY FROM PARENT ==================

      // Method 1: Listen for postMessage
      window.addEventListener("message", function (event) {
        log(
          `Received message from parent: ${JSON.stringify(event.data).substring(
            0,
            50
          )}...`
        );

        if (event.data && event.data.privateKey) {
          initWallet(event.data.privateKey);
        }
      });

      // Method 2: Check if privateKey set directly on window
      function checkWindowPrivateKey() {
        if (window.privateKey && !wallet) {
          log("Found privateKey on window object");
          initWallet(window.privateKey);
        }
      }

      // Check periodically (fallback)
      setInterval(checkWindowPrivateKey, 500);

      // ================== WALLET INITIALIZATION ==================
      async function initWallet(pk) {
        try {
          privateKey = pk;

          // Create provider for MegaETH
          provider = new ethers.providers.JsonRpcProvider(RPC_URL);
          log(`Connected to ${CHAIN_NAME} (${RPC_URL})`);

          // Create wallet from private key using ethers.js
          wallet = new ethers.Wallet(pk, provider);

          // Update UI
          walletStatus.textContent = "Connected âœ“";
          walletStatus.className = "status-value connected";

          const addr = wallet.address;
          walletAddress.textContent = `${addr.substring(
            0,
            6
          )}...${addr.substring(38)}`;

          log(`Wallet initialized: ${addr}`, "success");

          // Initialize token contract
          tokenContract = new ethers.Contract(TOKEN_ADDRESS, ERC20_ABI, wallet);
          log(`Token contract initialized: ${TOKEN_ADDRESS}`);

          // Fetch token info
          await fetchTokenInfo();

          // Fetch balances
          await fetchBalances();

          rollBtn.disabled = false;

          // Notify parent that we're ready
          notifyParent("GAME_READY", { 
            address: wallet.address,
            tokenAddress: TOKEN_ADDRESS,
            tokenSymbol: tokenSymbol
          });
        } catch (error) {
          log(`Error initializing wallet: ${error.message}`, "error");
          walletStatus.textContent = "Error: Invalid key";
          walletStatus.className = "status-value disconnected";
        }
      }

      // ================== FETCH TOKEN INFO ==================
      async function fetchTokenInfo() {
        try {
          log("Fetching token info...");
          
          // Get token symbol and decimals
          const [symbol, decimals, name] = await Promise.all([
            tokenContract.symbol(),
            tokenContract.decimals(),
            tokenContract.name()
          ]);
          
          tokenSymbol = symbol;
          tokenDecimals = decimals;
          tokenSymbolDisplay.textContent = symbol;
          
          log(`Token: ${name} (${symbol}), Decimals: ${decimals}`, "success");
        } catch (error) {
          log(`Error fetching token info: ${error.message}`, "error");
          // Use defaults
          tokenSymbol = "TOKEN";
          tokenDecimals = 18;
        }
      }

      // ================== FETCH BALANCES ==================
      async function fetchBalances() {
        if (!wallet || !provider) return;

        try {
          log("Fetching balances...");

          // Get native ETH balance
          const rawEthBalance = await provider.getBalance(wallet.address);
          ethBalance = parseFloat(ethers.utils.formatEther(rawEthBalance));
          ethBalanceEl.textContent = `${ethBalance.toFixed(6)} ETH`;

          // Get ERC-20 token balance
          const rawTokenBalance = await tokenContract.balanceOf(wallet.address);
          tokenBalance = parseFloat(ethers.utils.formatUnits(rawTokenBalance, tokenDecimals));
          tokenBalanceEl.textContent = `${tokenBalance.toFixed(4)} ${tokenSymbol}`;

          log(`ETH: ${ethBalance.toFixed(6)}, ${tokenSymbol}: ${tokenBalance.toFixed(4)}`, "success");
        } catch (error) {
          log(`Error fetching balances: ${error.message}`, "error");
          ethBalanceEl.textContent = "Error";
          tokenBalanceEl.textContent = "Error";
        }
      }

      // ================== GAME LOGIC ==================
      async function rollDice() {
        if (!wallet || !tokenContract) {
          log("No wallet connected!", "error");
          return;
        }

        const betAmount = parseFloat(betAmountEl.value);

        if (betAmount > tokenBalance) {
          log(`Insufficient ${tokenSymbol} balance! You have ${tokenBalance.toFixed(4)} ${tokenSymbol}`, "error");
          return;
        }

        if (betAmount <= 0) {
          log("Bet amount must be greater than 0!", "error");
          return;
        }

        // Disable button and start animation
        rollBtn.disabled = true;
        diceEl.classList.add("rolling");
        resultEl.style.display = "none";

        log(`Placing bet: ${betAmount} ${tokenSymbol}`);

        try {
          // ============ SIGN & SEND TOKEN TRANSACTION ============
          // Convert bet amount to token units (with decimals)
          const betAmountWei = ethers.utils.parseUnits(betAmount.toString(), tokenDecimals);

          // Create game data for signing
          const gameData = {
            action: "ROLL_DICE",
            betAmount: betAmount,
            token: TOKEN_ADDRESS,
            tokenSymbol: tokenSymbol,
            timestamp: Date.now(),
            nonce: Math.random().toString(36).substring(7),
          };

          const message = JSON.stringify(gameData);
          log(`Signing message: ${message.substring(0, 60)}...`);

          // Sign the message using the wallet
          const signature = await wallet.signMessage(message);
          log(`Signature created: ${signature.substring(0, 30)}...`, "success");

          // Verify signature (demo)
          const recoveredAddress = ethers.utils.verifyMessage(message, signature);
          log(`Signature verified. Recovered: ${recoveredAddress.substring(0, 10)}...`);

          // ============ TRANSFER TOKEN (Optional - for real betting) ============
          // Uncomment below to actually transfer tokens when playing
          /*
          log(`Transferring ${betAmount} ${tokenSymbol} to game treasury...`);
          const tx = await tokenContract.transfer(GAME_TREASURY, betAmountWei);
          log(`Transaction sent: ${tx.hash.substring(0, 20)}...`);
          await tx.wait();
          log(`Transaction confirmed!`, "success");
          */

          // For demo, we'll just simulate the game without actual transfer
          log(`[DEMO MODE] Simulating token transfer...`);

          // ============ GAME RESULT ============
          // Simulate dice roll (in real game, this would come from blockchain/server)
          await new Promise((resolve) => setTimeout(resolve, 1500));

          const diceResult = Math.floor(Math.random() * 6) + 1;
          const diceEmojis = ["âš€", "âš", "âš‚", "âšƒ", "âš„", "âš…"];

          diceEl.classList.remove("rolling");
          diceEl.textContent = diceEmojis[diceResult - 1];

          const isWin = diceResult >= 4;

          // Update local balance (in real game, this would refetch from blockchain)
          if (isWin) {
            tokenBalance += betAmount;
            log(`WIN! Dice: ${diceResult}, Won: ${betAmount} ${tokenSymbol}`, "success");
          } else {
            tokenBalance -= betAmount;
            log(`LOSE! Dice: ${diceResult}, Lost: ${betAmount} ${tokenSymbol}`, "error");
          }

          tokenBalanceEl.textContent = `${tokenBalance.toFixed(4)} ${tokenSymbol}`;

          // Show result
          resultEl.style.display = "block";
          resultEl.className = `result ${isWin ? "win" : "lose"}`;
          resultEl.innerHTML = isWin
            ? `ðŸŽ‰ You WIN! Rolled ${diceResult}. Won ${betAmount} ${tokenSymbol}!`
            : `ðŸ˜¢ You LOSE! Rolled ${diceResult}. Lost ${betAmount} ${tokenSymbol}.`;

          // ============ NOTIFY PARENT ============
          notifyParent("GAME_PLAY", {
            syncSusd: "True",
            result: isWin ? "WIN" : "LOSE",
            diceResult,
            betAmount,
            token: TOKEN_ADDRESS,
            tokenSymbol: tokenSymbol,
            signature: signature.substring(0, 20) + "...",
          });

          // Refresh balance from blockchain after game (in real implementation)
          setTimeout(fetchBalances, 2000);
        } catch (error) {
          log(`Error during game: ${error.message}`, "error");
          diceEl.classList.remove("rolling");
        } finally {
          rollBtn.disabled = false;
        }
      }

      // ================== COMMUNICATION WITH PARENT ==================
      function notifyParent(type, value) {
        const message = {
          type,
          value: typeof value === "string" ? value : JSON.stringify(value),
        };

        // Post message to parent window
        if (window.parent !== window) {
          window.parent.postMessage(message, "*");
          log(`Notify parent: ${type}`);
        }
      }

      // ================== EVENT LISTENERS ==================
      rollBtn.addEventListener("click", rollDice);

      // ================== INIT ==================
      log("Demo Game loaded. Waiting for privateKey from parent...");
      log(`Network: ${CHAIN_NAME}`);
      log(`RPC: ${RPC_URL}`);
      log(`Token: ${TOKEN_ADDRESS}`);

      // For standalone testing (without iframe)
      // Uncomment below to test directly with a test private key:
      // initWallet('YOUR_TEST_PRIVATE_KEY_HERE');
    </script>
  </body>
</html>
